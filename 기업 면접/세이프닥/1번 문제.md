[[2025-04-08]]
문제의 핵심 아이디어
- 처음에 줄 하나(1조각)에서 시작하여, 한 번의 오퍼레이션마다 겹치게 잘라서 추가 조각을 만드는 것을 반복하면서 최종적으로 n 조각을 얻기
- 한 번의 오퍼레이션에서 한 번에 m개의 줄을 잘라 (각 줄 당 1개씩 조각이 늘어나므로) 총 m개의 조각을 추가
- 단, m은 현재 가지고 있는 조각 수와 동시에 최대 허용치(즉, times 배열의 길이, 즉 ceil(n/2)) 내에서 선택

즉, DP 상태 dp[i]를 “1조각에서 시작해서 i조각을 만들기 위한 최소 시간”으로 정의하면,  
초기값: dp[1] = 0  
전이:
- 현재 조각의 개수가 i일 때, 1 ≤ m ≤ min(i, ceil(n/2)) 중에서 i + m ≤ n인 m을 선택하고  dp[i + m] = min(dp[i + m], dp[i] + times[m - 1])  
    최종적으로 dp[n]이 최소 시간

예를 들어, n = 4, times = [2, 3] 인 경우
- dp[1] = 0
- dp[2] = dp[1] + times[0] = 2
- dp[3] = min(dp[2]+times[0], …) = 2 + 2 = 4
- dp[4] = min(dp[2]+times[1], dp[3]+times[0]) = min(2+3, 4+2) = 5  
    따라서 최소 시간은 5
- **초기화:**  
    dp 배열은 1부터 n까지의 조각 개수를 표현하며, dp[1] = 0으로 설정하고 나머지는 초기 최대값으로 채우기
- **전이 과정:**  
    현재 조각 개수가 i개일 때, 사용할 수 있는 연산은 1 ≤ m ≤ min(i, maxSimultaneous)
    한 번에 m개 줄을 자르면, 시간은 times[m-1]가 소요되고 조각 수는 i + m
    이때 dp[i + m]을 갱신
- **최종 반환:**  
    최소시간 = dp[n]